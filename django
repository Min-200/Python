1.修改数据库模型
先修改appname/models　然后执行
python manage.py makemigrations appname
python manage.py migrate 


2.DateTimeField如何自动设置为当前时间并且能被修改

创建django的model时，有DateTimeField、DateField和TimeField三种类型可以用来创建日期字段，其值分别对应着datetime()、date()、time()三中对象。这三个field有着相同的参数auto_now和auto_now_add，表面上看起来很easy，但实际使用中很容易出错，下面是一些注意点。

DateTimeField.auto_now

这个参数的默认值为false，设置为true时，能够在保存该字段时，将其值设置为当前时间，并且每次修改model，都会自动更新。因此这个参数在需要存储“最后修改时间”的场景下，十分方便。需要注意的是，设置该参数为true时，并不简单地意味着字段的默认值为当前时间，而是指字段会被“强制”更新到当前时间，你无法程序中手动为字段赋值；如果使用django再带的admin管理器，那么该字段在admin中是只读的。

DateTimeField.auto_now_add

这个参数的默认值也为False，设置为True时，会在model对象第一次被创建时，将字段的值设置为创建时的时间，以后修改对象时，字段的值不会再更新。该属性通常被用在存储“创建时间”的场景下。与auto_now类似，auto_now_add也具有强制性，一旦被设置为True，就无法在程序中手动为字段赋值，在admin中字段也会成为只读的。

django中的日期时间字段

admin中的日期时间字段

auto_now和auto_now_add被设置为True后，这样做会导致字段成为editable=False和blank=True的状态。editable=False将导致字段不会被呈现在admin中，blank=Ture表示允许在表单中不输入值。此时，如果在admin的fields或fieldset中强行加入该日期时间字段，那么程序会报错，admin无法打开；如果在admin中修改对象时，想要看到日期和时间，可以将日期时间字段添加到admin类的readonly_fields中：

class YourAdmin(admin.ModelAdmin):
    readonly_fields = ('save_date', 'mod_date',)
admin.site.register(Tag, YourAdmin)
如何将创建时间设置为“默认当前”并且可修改

那么问题来了。实际场景中，往往既希望在对象的创建时间默认被设置为当前值，又希望能在日后修改它。怎么实现这种需求呢？

django中所有的model字段都拥有一个default参数，用来给字段设置默认值。可以用default=timezone.now来替换auto_now=True或auto_now_add=True。timezone.now对应着django.utils.timezone.now()，因此需要写成类似下面的形式：

from django.db import models
import django.utils.timezone as timezone
class Doc(models.Model):
    add_date = models.DateTimeField('保存日期',default = timezone.now)
    mod_date = models.DateTimeField('最后修改日期', auto_now = True)
    
    
    
    
    
    
    
3.在admin中显示其他的列
在admin中修改

from .models import Test

class Example(admin.ModelAdmin):
        list_display = ('name','date')

admin.site.register(Test, Example)






4.在admin中显示外键关系
polls/admin.py
from django.contrib import admin

from .models import Choice, Question


class ChoiceInline(admin.StackedInline):
    model = Choice
    extra = 3


class QuestionAdmin(admin.ModelAdmin):
    fieldsets = [
        (None,               {'fields': ['question_text']}),
        ('Date information', {'fields': ['pub_date'], 'classes': ['collapse']}),
    ]
    inlines = [ChoiceInline]

admin.site.register(Question, QuestionAdmin)






5.在url文件中写name=XXX
    　　格式为url(r'^post/(?P<name>正则)/$',views.视图函数,　name='名字')
       url(r'^post/(?P<pk>[0-9]+)/$', views.detail, name='detail'),
       url(r'^archives/(?P<year>[0-9]{4})/(?P<month>[0-9]{1,2})/$', views.archives, name='archives'),

在templates中调用url时
 <a href="{% url 'blog:archives' date.year date.month %}">{{ date.year }} 年 {{ date.month }} 月</a>

此处将date.year date.month 参数传递给url，访问archives/date.year/date.month




６.get_absolute_url
在models中定义该方法
class Post(models.Model):

        title = models.CharField(max_length=70)
        ....
        def __unicode__(self):
                return self.title
        def get_absolute_url(self):
                return reverse('blog:detail', kwargs={'pk': self.pk})
reverse方法用于重定向url，在这重定向到appname:name 即blog下的name=detail的url，并将参数pk传给url

在templates中需要查看对象模型时
<a href="{{ post.get_absolute_url }}" class="more-link">继续阅读 <span class="meta-nav">→</span></a>










