1.修改数据库模型
先修改appname/models　然后执行
python manage.py makemigrations appname
python manage.py migrate 


2.DateTimeField如何自动设置为当前时间并且能被修改

创建django的model时，有DateTimeField、DateField和TimeField三种类型可以用来创建日期字段，其值分别对应着datetime()、date()、time()三中对象。这三个field有着相同的参数auto_now和auto_now_add，表面上看起来很easy，但实际使用中很容易出错，下面是一些注意点。

DateTimeField.auto_now

这个参数的默认值为false，设置为true时，能够在保存该字段时，将其值设置为当前时间，并且每次修改model，都会自动更新。因此这个参数在需要存储“最后修改时间”的场景下，十分方便。需要注意的是，设置该参数为true时，并不简单地意味着字段的默认值为当前时间，而是指字段会被“强制”更新到当前时间，你无法程序中手动为字段赋值；如果使用django再带的admin管理器，那么该字段在admin中是只读的。

DateTimeField.auto_now_add

这个参数的默认值也为False，设置为True时，会在model对象第一次被创建时，将字段的值设置为创建时的时间，以后修改对象时，字段的值不会再更新。该属性通常被用在存储“创建时间”的场景下。与auto_now类似，auto_now_add也具有强制性，一旦被设置为True，就无法在程序中手动为字段赋值，在admin中字段也会成为只读的。

django中的日期时间字段

admin中的日期时间字段

auto_now和auto_now_add被设置为True后，这样做会导致字段成为editable=False和blank=True的状态。editable=False将导致字段不会被呈现在admin中，blank=Ture表示允许在表单中不输入值。此时，如果在admin的fields或fieldset中强行加入该日期时间字段，那么程序会报错，admin无法打开；如果在admin中修改对象时，想要看到日期和时间，可以将日期时间字段添加到admin类的readonly_fields中：

class YourAdmin(admin.ModelAdmin):
    readonly_fields = ('save_date', 'mod_date',)
admin.site.register(Tag, YourAdmin)
如何将创建时间设置为“默认当前”并且可修改

那么问题来了。实际场景中，往往既希望在对象的创建时间默认被设置为当前值，又希望能在日后修改它。怎么实现这种需求呢？

django中所有的model字段都拥有一个default参数，用来给字段设置默认值。可以用default=timezone.now来替换auto_now=True或auto_now_add=True。timezone.now对应着django.utils.timezone.now()，因此需要写成类似下面的形式：

from django.db import models
import django.utils.timezone as timezone
class Doc(models.Model):
    add_date = models.DateTimeField('保存日期',default = timezone.now)
    mod_date = models.DateTimeField('最后修改日期', auto_now = True)
    
    
    
    
    
    
    
3.在admin中显示其他的列
在admin中修改

from .models import Test

class Example(admin.ModelAdmin):
        list_display = ('name','date')

admin.site.register(Test, Example)






4.在admin中显示外键关系
polls/admin.py
from django.contrib import admin

from .models import Choice, Question


class ChoiceInline(admin.StackedInline):
    model = Choice
    extra = 3


class QuestionAdmin(admin.ModelAdmin):
    fieldsets = [
        (None,               {'fields': ['question_text']}),
        ('Date information', {'fields': ['pub_date'], 'classes': ['collapse']}),
    ]
    inlines = [ChoiceInline]

admin.site.register(Question, QuestionAdmin)






5.在url文件中写name=XXX
    　　格式为url(r'^post/(?P<name>正则)/$',views.视图函数,　name='名字')
       url(r'^post/(?P<pk>[0-9]+)/$', views.detail, name='detail'),
       url(r'^archives/(?P<year>[0-9]{4})/(?P<month>[0-9]{1,2})/$', views.archives, name='archives'),

在templates中调用url时
 <a href="{% url 'blog:archives' date.year date.month %}">{{ date.year }} 年 {{ date.month }} 月</a>

此处将date.year date.month 参数传递给url，访问archives/date.year/date.month

这里 (?P<pk>[0-9]+) 表示命名捕获组，其作用是从用户访问的 URL 里把括号内匹配的字符串捕获并作为关键字参数传给其对应的视图函数 detail。
比如当用户访问 post/255/ 时（注意 Django 并不关心域名，而只关心去掉域名后的相对 URL），被括起来的部分 (?P<pk>[0-9]+) 匹配 255，
那么这个 255 会在调用视图函数 detail 时被传递进去，实际上视图函数的调用就是这个样子：detail(request, pk=255)。
我们这里必须从 URL 里捕获文章的 id，因为只有这样我们才能知道用户访问的究竟是哪篇文章。

注意到 URL 配置中的 url(r'^post/(?P<pk>[0-9]+)/$', views.detail, name='detail') ，
我们设定的 name='detail' 在这里派上了用场。
看到这个 reverse 函数，它的第一个参数的值是 'blog:detail'，意思是 blog 应用下的 name=detail 的函数，
由于我们在上面通过 app_name = 'blog' 告诉了 Django 这个 URL 模块是属于 blog 应用的，
因此 Django 能够顺利地找到 blog 应用下 name 为 detail 的视图函数，
于是 reverse 函数会去解析这个视图函数对应的 URL，
我们这里 detail 对应的规则就是 post/(?P<pk>[0-9]+)/ 这个正则表达式，
而正则表达式部分会被后面传入的参数 pk 替换，
所以，如果 Post 的 id（或者 pk，这里 pk 和 id 是等价的） 是 255 的话，那么 get_absolute_url 函数返回的就是 /post/255/ ，
这样 Post 自己就生成了自己的 URL。



６.get_absolute_url
在models中定义该方法
class Post(models.Model):

        title = models.CharField(max_length=70)
        ....
        def __unicode__(self):
                return self.title
        def get_absolute_url(self):
                return reverse('blog:detail', kwargs={'pk': self.pk})
reverse方法用于逆向查找URLCONF ，根据提供的视图和参数的值来逆向查找URLconf，匹配相应的url然后把值拿回来



在templates中需要查看对象模型时
<a href="{{ post.get_absolute_url }}" class="more-link">继续阅读 <span class="meta-nav">→</span></a>










